-- Ce script doit être exécuté dans l'éditeur SQL de Supabase.
-- Il va supprimer les anciennes tables (si elles existent) et créer la nouvelle structure.

-- ÉTAPE 1: Supprimer les anciennes tables pour un redémarrage propre (Optionnel mais recommandé)
DROP TABLE IF EXISTS public.donnees_horaires;
DROP TABLE IF EXISTS public.simulations;
DROP TABLE IF EXISTS public.donnees_capteurs_reels; -- On ajoute la nouvelle table ici aussi

-- ÉTAPE 2: Créer la table pour les résumés de simulation
CREATE TABLE public.simulations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    simulation_mode TEXT,
    latitude FLOAT8,
    longitude FLOAT8,
    altitude FLOAT8,
    panel_width FLOAT8,
    pivot_height FLOAT8,
    max_tilt FLOAT8,
    axis_azimuth FLOAT8,
    pitch_simulated FLOAT8,
    crop_name TEXT,
    water_savings_percent FLOAT8,
    dli_under_panels FLOAT8,
    dli_open_field FLOAT8,
    peak_temp_under_panels FLOAT8,
    peak_temp_open_field FLOAT8,
    et_under_panels_mm FLOAT8,
    et_open_field_mm FLOAT8
);

-- ÉTAPE 3: Créer la table pour les données horaires détaillées (issues de la simulation)
CREATE TABLE public.donnees_horaires (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    simulation_id BIGINT REFERENCES public.simulations(id) ON DELETE CASCADE, -- Clé étrangère
    "timestamp" TIMESTAMPTZ NOT NULL,
    ghi_open_field FLOAT8,
    ghi_agrivoltaic FLOAT8,
    temp_open_field FLOAT8,
    temp_agrivoltaic FLOAT8,
    wind_speed FLOAT8,
    relative_humidity FLOAT8,
    panel_tilt FLOAT8
);

-- ÉTAPE 5: Créer la nouvelle table pour les données des capteurs en temps réel
-- Cette table est maintenant alignée avec les données envoyées par le script Python.
CREATE TABLE public.donnees_capteurs_reels (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(), -- L'heure exacte de l'insertion
    nom_capteur TEXT DEFAULT 'virtual_sensor_1', -- Nom du capteur/source de données

    -- Données Météo brutes
    ghi_open_field FLOAT8,
    dhi_open_field FLOAT8,
    dni_open_field FLOAT8,
    temperature_air FLOAT8,
    wind_speed FLOAT8,
    relative_humidity FLOAT8,

    -- Données Agrivoltaïques calculées
    shading_ratio FLOAT8,
    ghi_agrivoltaic FLOAT8,
    humidite_sol FLOAT8,
    power_output_mw FLOAT8,

    -- Données journalières (calculées par le script et répétées chaque heure)
    dli_open FLOAT8,
    dli_agri FLOAT8,
    et_open FLOAT8,
    et_agri FLOAT8,
    water_savings FLOAT8,
    daily_production_mwh FLOAT8
);


-- ÉTAPE 6: Désactiver la sécurité RLS pour toutes les tables
-- C'est la solution la plus simple pour votre cas d'usage où l'application est la seule à écrire.
ALTER TABLE public.simulations DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.donnees_horaires DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.donnees_capteurs_reels DISABLE ROW LEVEL SECURITY; -- On ajoute la nouvelle table ici

-- Message de confirmation
SELECT 'Tables "simulations", "donnees_horaires", et "donnees_capteurs_reels" créées avec succès et RLS désactivé.';

-- Étape 1: Créer la fonction qui retourne la liste des plantes uniques
create or replace function get_unique_crop_names()
returns table(crop_name text) as $$
begin
  return query
  select distinct s.crop_name from simulations s order by s.crop_name;
end;
$$ language plpgsql;

-- Étape 2: Donner la permission au rôle 'anon' d'utiliser cette fonction
GRANT EXECUTE ON FUNCTION public.get_unique_crop_names() TO anon;

